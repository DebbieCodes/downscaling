# Reconstructing a high resolution image from a low resolution image by extending the spectral tail to higher frequencies.import numpy as npimport scipy.ioimport matplotlib.pyplot as plt#%% Load filemat = scipy.io.loadmat('downscaling.mat')zhi = mat['zhi'] # hi res (target)zlo = mat['zlo']# low res (given)fig,ax = plt.subplots(1,2)ax[0].contourf(zlo)ax[0].set(title='Low res')ax[1].contourf(zhi)ax[1].set(title='High res')#%% Inspect the spectrumzlo_f_x = np.fft.fft(zlo,axis=0)zhi_f_x = np.fft.fft(zhi,axis=0)zlo_f_y = np.fft.fft(zlo,axis=1)zhi_f_y = np.fft.fft(zhi,axis=1)nx=256fig,[ax,ax2] = plt.subplots(2,2)ax[0].semilogy(abs(zlo_f_x), '--r', label='x low res')ax[0].semilogy(abs(zhi_f_x), ':b', label='x high res')ax[0].set(title='Fourier X-dir, red= low res, blue = high res', xlim=[0,round(nx/2)])ax[1].semilogy(abs(zlo_f_y).T, '--r', label='x low res')ax[1].semilogy(abs(zhi_f_y).T, ':b', label='x high res')ax[1].set(title='Fourier Y-dir', xlim=[0,round(nx/2)])ax2[0].semilogy(abs(zlo_f_x[:,0]), '--r', label='x low res')ax2[0].semilogy(abs(zhi_f_x[:,0]), ':b', label='x high res')ax2[0].set(title='Fourier X-dir, 1 line', xlim=[0,round(nx/2)])ax2[1].semilogy(abs(zlo_f_y[0,:]), '--r', label='x low res')ax2[1].semilogy(abs(zhi_f_y[0,:]), ':b', label='x high res')ax2[1].set(title='Fourier Y-dir, 1 line', xlim=[0,round(nx/2)])plt.tight_layout()#%% Reconstruct high res from low res# fit powerlaw on mean of tail high resx_start = 8x_end = 60x_sel = np.arange(x_start,x_end)x_sel2 = np.tile(x_sel,(nx,1)).Ttemp1 = np.log10(abs(zhi_f_x[x_sel,:]))m, b = np.polyfit(x_sel2.ravel(),temp1.ravel(),1)fig,ax = plt.subplots()ax.plot(np.log10(abs(zhi_f_x)),linestyle='none', marker=',')ax.plot(x_sel,b+m*x_sel)ax.set(title='Fit on tail')# For one side of the spectrum:# for low res, extend tail based on found powerlaw, with added noise# add random phases to new modes def getFakeTail(zlo_f,zhi_f,x_sel):    nx=np.size(zlo_f,1)    x_sel2 = np.tile(x_sel,(nx,1)).T    temp1 = np.log10(abs(zhi_f[x_sel,:]))    m, b = np.polyfit(x_sel2.ravel(),temp1.ravel(),1)        zrec_f = np.copy(zlo_f)        for jj in range(nx):        fake_tail_abs1 = np.log10(abs(zlo_f[x_start-1,jj]))  + m*x_sel        fake_tail_abs  = 10**(fake_tail_abs1)        n_tail=len(x_sel)        # add some noise to the values        noise_fact =1        fake_tail_abs = (np.random.rand(n_tail)*noise_fact+1)*fake_tail_abs        # random phases for the fake tail        phi = np.random.uniform(low=0, high=2*np.pi, size=(len(x_sel),))        fake_tail = fake_tail_abs*np.exp(1j*phi)        zrec_f[x_sel,jj] = fake_tail        # Flip to create the other side of the spectrum:        zrec_f[-1*x_sel,jj] = -1j*fake_tail          if jj ==1: # make a plot for inspection                fig,ax = plt.subplots()                ax.plot(np.log10(abs(zhi_f[:,jj])),linestyle='-', marker=',')                ax.plot(np.log10(abs(zlo_f[:,jj])),linestyle='-', marker=',')                ax.plot(np.log10(abs(zrec_f[:,jj])),linestyle='-', marker=',')                    return zrec_fzrec_f_x = getFakeTail(zlo_f_x ,zhi_f_x,x_sel)zrec_f_y = getFakeTail(np.swapaxes(zlo_f_y,0,1) ,np.swapaxes(zhi_f_y,0,1),x_sel)zrec_f_y = np.swapaxes(zrec_f_y,0,1)# transform to real spacezrec_x= np.real(np.fft.ifft(zrec_f_x,axis=0))zrec_y= np.real(np.fft.ifft(zrec_f_y,axis=1))zrec = (zrec_x + zrec_y)/2fig,ax = plt.subplots(1,3)ax[0].contourf(zrec_x)ax[0].set(title='Reconstr x')ax[1].contourf(zrec_y)ax[1].set(title='Reconstr y')ax[2].contourf(zrec)ax[2].set(title='Combined')#%% Comparison plotsfig,ax = plt.subplots(1,3)ax[0].contourf(zlo)ax[0].set(title='Low res')ax[1].contourf(zhi)ax[1].set(title='High res')ax[2].contourf(zrec)ax[2].set(title='Reconstruction')plt.tight_layout()fig.savefig('reconstructionAttempt.jpg')